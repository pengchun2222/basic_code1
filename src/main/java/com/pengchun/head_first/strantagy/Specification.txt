我们的产品种有很多种鸭子，有绿头鸭，红头鸭.......
我们将所有鸭子的共同属性进行抽取，他们会叫quack(),会游泳swim(),在这方面他们都是统一的
但是不同的鸭子有不同的外观和描述，于是有一个抽象方法display()，每种鸭子有不同的外观，在继承超类duck后进行重写。
这个时候需求出现，我们目前所有的鸭子都要会飞。
所以在duck类中加一个fly()方法，那么所有鸭子都有飞这个属性了

但是现在新增一种橡胶鸭子，橡胶鸭子只会吱吱的叫并且不会飞，于是在橡胶鸭子的实现类种我们需要重写fly()方法并且在方法种不做操作。同时需要重写quack()方法，改为吱吱
又新增一种鸭子叫饵鸭（木头鸭子），木头鸭子不会叫也不会飞，那么我们需要重写fly()和quack()并在实现种不做任何操作
又新增.....

因为继承而实现的代码复用在此处遇到极大的障碍，让每一次的新种类都需要重复的覆盖其他方法，并且如果在超类新增或者删除方法后，子类变化极大。
于是我们将飞和叫提取出来作为一个接口

需要叫的鸭子实现叫的接口，同理需要飞的鸭子实现飞的接口
这样做会导致代码变得更为冗余。

我们定义飞和叫的行为接口
让不同的行为方式来实现接口
这些行为和鸭子本身没有关系了，当我们新增一些行为后，新的行为并不会影响别的使用了其他行为的鸭子
在具体的鸭子类的构造器中设置需要的行为实现类，在通过set方法可以动态设置行为实现类，使其可以动态改变行为实现

那么飞行、叫就是不同的行为组，而所有具体的飞行和叫又是一组行为下不同的实现类