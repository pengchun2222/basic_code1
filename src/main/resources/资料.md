什么是面向对象：
	面向过程将任务拆解为一系列的步骤，而面向对象将各步骤聚合在拆分成各个不同的对象，根据每个对象不同的功能做不同的事
	面向过程比较噶高效，面向对象更易于复用、维护、扩展
面向对象三大特性
	封装：内部细节不对外部调用透明，外部调用无须修改或者关心内部实现
		例如：javabean orm框架：我们不需要关心链接的建立，sql如何执行，引用mybatis调用即可。
	继承：继承基类的方法，并作出自己的改变和扩展
	多态：继承，方法重写，父类指向子类对象List list = new ArrayList()。外部调用通过一个方法吗，实际执行逻辑不同。无法调用子类特有功能。
	
JVM:
	JAVA跨平台是基于JVM实现，JVM会将.class文件编译成不同平台得到机器码。
	组成部分：
		类装载子系统（类加载器）
		内存模型：
			堆：存放具体对象的地方。年轻代 1/3 (eden :s0:s1 = 8:1:1)，老年代 2/3
				GC Roots 可达性分析算法：将GC Roots对象作为起点，从这些节点开始向下搜索引用对象，找到的对象都标记为非垃圾，其余的都是垃圾。
				GC Roots根节点：栈的本地变量、静态变量，本地方法栈的变量等
				分代年龄默认15 
				工具：arthas  wget https://alibaba.github.io/arthas/arthas-boot.jar 
				老年代满了之后，gc会启动一个线程做full gc。触发STW（停止所有用户线程）
				gc调优就是为了减少full gc
				STW出现的目的，防止对象状态发生改变（假设没有stw，full gc触发标记某些对象不是垃圾，用户线程继续执行，释放垃圾，会出现full gc标记不是垃圾但已经成为垃圾的对象存在）

​				java -Xms3G -Xmm3![微信图片_20210323223410](C:\Users\Administrator\Desktop\资料\微信图片_20210323223410.png)G  -Xss1M -xx:MetaspaceSize:512M -Xx:MaxMetaspaceSize=512M -jar xxx.jar

​		老年代分配1g内存，年轻代分配2g。此时eden,s0,s1分别为1.6g，0.2g，0.2g。线程每秒产生60mb对象，s0能够容纳下下一次gc时eden中的垃圾，不会触发年龄动态分配，从而解决问题。



​		![微信图片_20210323222932](C:\Users\Administrator\Desktop\资料\微信图片_20210323222932.png)

​	默认gc内存分配：
​			栈：只要线程开始运行，就会在整个栈空间中分配一块栈空间给线程使用，每个线程执行到一个方法，会给分配一个栈帧空间。
​				栈帧空间： 局部变量 
​				操作数栈：数据运算过程中临时存放的数据
​				动态链接：将符号引用转换为直接引用。用于寻找方法存放在方法区的内存地址。
​				方法出口：保证方法结束后继续向下执行

​	本地方法栈： 保存native方法进入区域的地址。 
​	方法区：
​		元空间：
​		常量：
​		静态变量：存放具体对象的内存地址 User user = new user() ，new 							user()存放在堆，user存放在静态变量中类的信息
​	程序计数器（每个线程都有）：用来存放即将执行的那一行代码的行号、内存地址。				cpu多线程执行时，接着执行的依据

  





String、StringBuffer、StringBuilder

String是被final修饰的，每次修改创建新的对象，在String需要被频繁修改时使用StringBuffer或者Stringbuilder。

StringBuffer是线程安全的（synchronized）。StringBuilder是线程不安全的，StringBuilder效率更高。在多线程修改String时使用StringBuffer



重载、重写

重载：发生在同一个类中，方法名相同，参数个数不同，参数顺序不同，参数类型不同。返回值和修饰符不同不是重载，会在编译时报错

重写：发生在父子类中，子类重写父类非私有方法，方法名，参数相同，返回值和异常范围小于父类。



抽象类和接口的区别

关键字不同，抽象类被abstract修饰。

抽象类可以有普通方法。

抽象类只能实现继承一个，接口可以多实现。

抽象类成员变量可以是各种类型，接口成员变量比赛是static final 修饰



ArrayList和LinkedList的区别

ArrayList:基于动态数组，连续内存存储，适合下标访问。数组长度固定 ，超出长度新建数组，将老数组考入新数组中，不是尾部插入和删除会涉及元素的移动。尾部插删并指定初始化容量，能极大提升性能，超过LinkedList。

LinkedList:基于链表，分散存储于内存，适合做删除和插入。必须使用迭代器，不可使用for。



HashMap/HashTable

区别：hashTable每一个方法加了一个synchronized，线程安全。HashMap线程不安全

​			HashMap允许key、value值为null，HashMap不允许



​			JDBK8中数组+链表，当链表长度到8或者数组长度到64链表转为红黑树。寻址算法优化：数组长度-1 &

​			hashcode 获取下标。hash算法算法，hash值16进组右移16位与hash值&运算。尽量避免hash冲突

​			

​			元素先放在数组中，出现hash冲突后，进行equals比较，相同则取代。不同，现有元素挤掉原有元素在数组中的位置，与原有元素建立链表结构，并产生指标指向原元素。

​			

ConcurrentHashMap中JDK8和JDK7的区别

​		JDK7:ReentrantLock+segment+HashEntry	

元素操作：二次hash，第一次定位到segment，第二次定位到链表头。用segment的分段加锁。segment继承了ReentrantLock。锁定操作的segment，其他segment不受影响，数组扩容也不会影响到别的segment。最大并发数为segment个数。

​	JDK8:synchronized+CAS+Node+红黑树，Node的Val和next都用volatile修饰，保证可见性。

查找，替换，复制都使用CAS操作。

锁链表的Head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时阻塞所有操作，并发扩容。

读操作无所



如何实现一个ioc容器

配置文件指定需要扫描的包路径

定义一些注解，分别表示访问控制层，业务层，服务层，持久层，依赖注入注解。

从配置文件中获取需要扫描的包路径，获取当前路径的文件信息，找到以.class结尾的文件添加到set集合存储。

便利set集合。通过反射获取指定注解的类。定义一个map集合存储对象



什么是字节码

​	虚拟机能够理解的代码叫字节码。（.class文件）,字节码由虚拟机解释执行。

字节码的好处

​	java通过字节码一定程度上解决了传统解释型语言执行效率底下的问题。字节码不专一对一种特定的机制。只面对jvm。一次编译永适用。

java类加载器：

​	三种:BootstrapClassLoader/ExtClassLoader/AppClassLoader

​	%JAVA_HOME%\lib 下的jar和class/	%JAVA_HOME%\lib\exc下的jar、class/classpath下的类文件 



双亲委托模型：

​	向上查找缓存AppClassLoad->ExtClassLoader ->BootstrapClassLoader  

​	向下查找路径BootstrapClassLoader ->ExtClassLoader->AppClassLoad

​	主要是为了安全性，避免自己编写的类动态替换java核心类，比如String

​	避免类重复加载，相同的class不同的ClassLoadr加载就是不同的两个类



JAVA中的异常体系

​	所有异常类都来自顶级父类Throwable

​	Exception/Error

​	Eorror表示程序无法自己解决OOM，强值程序停止运行

​	Exception : RUnTimeException/CheckException 运行时异常/编译时异常



线程的生命周期以及状态

​	1、新建状态（New）：新创建了一个对象

​	2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start方法。该线程存放于可运行线程中。等待获取cpu的使用权。

​	3、运行状态（Running）：线程获取到cpu执行权，执行代码。

​	4、阻塞状态（Blocked）：阻塞是因为线程因为某种原因放弃cpu执行权，暂时停止运行。

​	5、死亡状态（Dead）:线程执行完了或者因异常退出run方法。

​	阻塞状态：

​		1、等待阻塞：运行时线程执行wait()方法，释放占用资源，进入等待池中。这个状态不能自动唤醒，需要notify或者notifyall才能被唤醒。

​		2、同步阻塞：取锁失败，进入锁池。

​		3、其他阻塞：执行sleep或者join方法，或者发出i/o请求。



锁池

​	竞争失败等待抢锁的线程进入锁池

等待池

​	wait方法调用后进入等待池，唤醒后进入锁池



Sleep和wait的区别

​	sleep是Thread类的本地方法，wait是Object的本地方法

​	sleep不会释放锁，wait释放锁进入等待池

​	sleep不需要依赖synchronized，wait需要依赖

​	sleep不需要被唤醒，时间到了就醒了，wait需要被唤醒



yield() 直接释放cpu执行权，进入就绪状态，还会去抢cpu执行权

join()，A线程调用B线程的join()，A会进入阻塞状态知道B执行完毕。



线程安全

​	多个线程访问同一个对象时，调用这个对象的行为都可以获得正确的结果，则该对象是安全的。



守护线程：为所有非守护线程（用户线程）提供服务的线程。





Thread和runnable的区别

​	没什么区别，Thread是runnable的实现类。只有使用方式上的区别。



ThreadLocal内部有一个内部类ThreadLocalMap，ThreadLocal的set方法先获取当前对象，调用当前对象的ThreadLocalMap。最终调用的是ThreadLocalMap的set方法，ThreadLocalMap会使用一个叫Entry的对象，Entry是可以俄国key-value泛型的一个对象。Entry的key是使用ThreadLocal自身的netHashcode()方法获取的一个唯一值作为key，

ThreadLocalMap是每个线程独立的拥有的，所以不会存在线程安全问题。

ThreadLocal的使用场景

跨层参数传递，线程间的数据隔离，事务操作，数据库连接。



ThreadLocal内存泄漏问题：

​	内存泄漏：不在使用的对象或变量占用的内存无法回收	

​	强引用：new 对象就属于强引用，jvm抛出OOM也不会回收

​	弱引用：无论内存是否充足，jvm都会对其进行回收。类似缓存。

​	ThreadLocalMap使用ThreadLocal的弱引用作为key，如果ThreadLocal没有强应用会被gc回收，导致ThreadLocalMap中的key为null,而value是强引用无法回收。

​	因为如果使用ThreadLocal的强引用会导致ThreadLocal永远无法被回收，使用弱引用，当ThreaLocalMap调用set，get，remove的方法时均会清楚value值。



并发、并行、串行

串行：同一时间点，只能有一个任务在执行，别人任务等着前一个任务执行完

并行：多个任务同时执行，互不干扰

并发：通过任务交替执行。互相干扰、



线程池处理流程：

​	

![1616855120658](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1616855120658.png)



线程池中阻塞队列的作用

​	阻塞队列可以保留住想要要继续入队的任务

​	当阻塞队列中没有任务时阻塞获取任务的线程，使线程进入wait状态，释放cpu资源

​	阻塞队列自带阻塞和唤醒功能，不需要做额外处理，无任务时，利用阻塞任务的task方法挂起，而且维持核心线程存货，不至于一直占用cpu



为什么先添加队列而不是先创建最大线程

​	在创建线程的时候，需要用到全局锁，其他的线程都会阻塞，影响整体效率



线程池的复用原理

​	线程池将任务和线程解耦。在线程池中，线程可以从阻塞队列中获取新任务来执行，对thread进行封装，让每个线程执行一个循环任务。不调用thread的start方法，不开启子线程，循环任务不停检查是否有任务需要被执行，如果有则执行，直接调用run方法当一个普通方法来执行，通过这周方式只是用固定的线程就将所有任务的run串联起来。



Spring是什么

​	Spring是一个轻量的控制反转（IOC）和面向切面（AOP）的容器框架

​	控制反转松耦合。

​	面向切面允许分离应用的业务逻辑

​		

对AOP的理解

​	将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象中中去。AOP可以对某个对象或者某些对象的功能进行增强，也可以在执行某个方法之前或之后额外的做一些事情。（加解密）



对IOC的理解

​	IOC本身就是一个map容器，在其中存储各种对象。在项目启动的时候会读取配置文件中的节点，根据全限定类名使用反射创建对象放在map集合中。	

​	控制反转：将全部对象的控制权上缴给IOC容器。由以前自己new对象变为从ioc中获取对象。从主动变为被动。

​	依赖注入：依赖注入是实现ioc的方法，在ioc容器运行期间，动态将某种依赖注入到对象之中。

​	

BeanFactory和ApplicationContext的区别

​	BeanFactory是Spring最底层的接口，ApplicationContext继承了BeanFactory

​	ApplicationContext提供了更完整的功能：

​		继承了MessageResouce,具有国际化

​		提供在监听器中注册bean

​		同时加载多个配置文件

​	BeanFactory使用懒加载注入bean，需要使用时才通过getBean队Bean进行实例化。

​	ApplicationContext在容器创建时要一次性创建所有的Bean。

​	ApplcationContext占用较多空间，启动较慢



Spring Bean的生命周期

​	1、实例化  doCreateBean() - >createBeanInstance ()

​	2、属性赋值	doCreateBean() - > populateBean()	

​	3、初始化	 doCreateBean() - > initializeBean()

​	4、销毁   ConfigurableApplicationContext .cloce() 或者容器停止



​	InstantiationAwareBeanPostProcessor 实例化前后扩展点 BeanPostProcessor子类

​	BeanPostProcessor	初始化前后扩展点



​	Aware类型的接口 BeanNameAware 获取Beanname Aware类型接口在initializeBean中调用

SpringBean的作用域

​	singleton：单例，默认的，由beanFactory自身维护，第一次被注入时创建

​	prototype：多例，每次getBean提供一个实例

​	request:单例，在每次http请求中创建一个对象。

​	session:定义在session生命周期中的单例

​	websocket:定义在websocket生命周期中的单例

​	appliation:定义在ServletContext生命周期中的单例，跨容器。

​	global_session:全局作用域



Spring中单例Bean的线程安全么

​	不安全的

​	Spring中的Bean默认单例，没有进行多线程封装处理。 

​	如果Bean是有状态的，则不是线程安全的。

​		有无状态看是否有数据存储功能。



Spring框架都用到了那些设计模式

​	简单工厂：BeanFactory就是一个简单工厂。根据传入的唯一标识来获取对象

​	工厂方法：实现FactoryBean接口的bean，在嗲用getBean()，其实调用的是getObject(),返回的不是factory的bean，二十getObject()的返回值。

​	单例：Spring创建bean默认都是单例模式

​	适配器模式

​	装饰器：Spring中类名带有Wrapper或者Decorator都是使用装饰器。

​	动态代理：aop

​	观察者

​	策略模式



Spring事务的实现方式和原理以及隔离级别

​	Spring事务就是数据库事务，spring是调用了数据库的事务。事务的实现方式有两种，一种是编程式的一种是声明式的（@Transactional）。被Transcational修饰的类会生成一个代理对象，会将这个代理对象作为bean。代理对象会把事务的自动提交设置为false。然后执行逻辑方法。逻辑方法没有出现异常在提交。

​	Spring的隔离级别就是数据库的隔离级别，外加一个默认级别（其实就是数据库的默认级别）

​	read uncommitted

​	read committed

​	repeatable read

​	serializable

​	最终以spring隔离级别为准，如果spring设置的隔离级别数据库不支持，效果看数据库。



Spring事务的传播方式

​	a()-b(); a：当前事务，b:自己

​	REQUIRED(默认)：有事务则加入，没有事务则新建

​	SUPPORTS：有则加入，没有则非事务运行

​	MANDATORY：有则加入，没有抛异常

​	REQUIRED_NEW：创建一个新事务，存在当前事务则挂起该事务（互不干扰，各搞个的）

​	NOT_SUPPORTED：非事务运行，有当前事务则挂起当前事务

​	NEVER：不使用事务，存在当前事务，抛异常。

​	NESTED：当前事务存在，嵌套事务中执行，否则开启一个事务。（父事务回滚，子事务回滚。子事务回滚，父事务不一定回滚）



Spring事务什么时候会失效。

​	Spring事务的原理是AOP，进行了切面增强。失效的原有是AOP不起作用。

​		1、发生自调用。类里面使用this调用本类的方法，此时this的对象不是代理对象。是自己本身。

​		2、方法不是public,@Transactional只能用于public 方法上。

​		3、数据库不支持事务

​		4、没事被spring管理

​		5、异常被catch掉



Spring、SpringMVC、Spring Boot

​	Spring是一个IOC容器。用来管理Bean，使用依赖注入实现控制反转，方便整个其他框架，使用AOP机制弥补OOP的代码重复问题。

​	SpringMVC是Spring对web框架的一个解决方案

​	SpringBoot是Spring提供的一个快速开发工具包，使用了起步依赖，自动装配。





SpringMVC工作流程

​	1、请求发送至前端控制器DispatcherServlet

​	2、DispatcherServlet调用HandlerMapping处理器映射器

​	3、通过HandlerMapping找到具体的处理器。生成处理器返回给前端控制器

​	4、前端控制器调用HandlerAdapter处理器适配器

​	5、HandlerAdapter经过适配调用具体的处理器（controller后端控制器）

​	6、controller执行完返回modelAndView

​	7、handlerApdater将modelAndView返回给DispatchServlet,最后传给ViewResolver实体解析器。

​	8、ViewResolver解析后返回view

​	9、DispatcherSevlet根据view进行视图渲染

​	10、DispatcherServlet响应给用户



Spring Boot自动配置的原理

​	@Import(AutoConfigurationImportSelectors.class),@Configuration.Spring spi机制

​	自动装配的类由各个start提供，使用@Configuration和@Bean定义配置类

​	Spring spi 扫描Spring.factories下的配置类。

​	通过Import导入



如何理解Spring boot中的starter

​	使用Spring+Springmvc使用，如果需要引入mybatis框架，需要到xml中定义mybaits需要的bean.

​	starter就是定义一个starter的jar包，写一个@configuration配置类，将这些bean定义在里面，然后在starter的META-INF/Spring.factories中写入配置类的全路径类名，Spring会按找约定来加载该配置类。



mybatis优缺点

​	优点：基于sql语句编程，比较灵活，不会对应用程序及数据库现有设计造成影响，支持动态sql语句，并可重用。

​				能够与spring很好的集成

​				不需要手动开关jdbc连接

​				很好的和各种数据库兼容

​				提供映射标签，支持对象与数据库的字段关系映射

​	缺点：sql语句编写工作量大。

​				sql语句依赖数据库，不可随意跟换数据库



mybatis和hibernate的不同

​	java的基本思想是面向对象，而我们在开发程序时，首先设计数据库，变成了面向表结构编程。

​	国内现状导致迭代速度过快。面向表结构开发的话会更灵活一点。

​	开发速度对比：

​		当项目中用到的复制查询基本没有，只是简单的crud使用hibernate效率会高很多。反之mybatis会好很多，mybatis对语句的管理更方便。

​	工作量对比：

​		mybatis需要手写sql语句，resultmap。hibernate有良好的映射机制。

​	sql优化

​	hibernate的查询会将表中的所有字段查询出来，有性能消耗，也可以手写，但是会破坏开发的简洁性。

​	对象管理

​		hibernate是完整的对象/关系模型 ORM。

​	hibernate功能比较强大，数据库无关性好，O/R映射能力强。

​	hibernate比较难，mybatis比较简单



#{}和${}的区别

​	#{}是预编译，占位符

​	${}是替换符	

​	#{}可以有效防止sql注入



索引的基本原理

​	快速寻找具有特定值的记录，如果没有所有，执行查询遍历全表

​	把无序的数据编程有序的查询

​		1、把创建了所有的内容进行排序

​		2、对排序结果生成倒排表

​		3、在倒排表内容上拼上数据地址链

​		4、在查询的时候，先拿到倒排表内容，在取出数据地址链，从而拿到数据



聚簇索引和非聚簇索引的区别

​	都是b+数数据结构

​		聚簇索引：将数据存储和索引放在一起，按照一定的顺序组织的，找到索引就找到数据。

​		非聚簇索引：叶子节点不存储数据，存储数据的行地址。

​	优势：

​		1、通过聚簇索引可直接获取数据，不需要像非聚簇索引一样二次查找，效率高

​		2、聚簇索引范围查询效率高，数据按大小排序

​		3、聚簇索引适合用在排序的场合，非聚簇不合适

​	劣势：

​		1、维护索引代价高，大量插入新行，索引移动。移动的行数据会产生碎片。优化：				(OPTIMIZE TABLE 优化表，独享表空间)

​		2、表使用uuid作为主键，会使数据存储稀疏，这就会出现聚簇索引有可能比全表扫描更慢。建议使用int类型的auto_increment作为主键

​		3、主键大会导致辅助索引（除主键外的索引都是辅助索引）更大，占用叶子物理空间。

​	InnoDB中一定有主键，主键一定是聚簇索引，不手动设置，则会使用唯一索引，没有唯一，从数据库内部的一个行的隐藏id来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引。辅助索引访问数据需要二次查找，辅助索引叶子节点存储的是主键值。

​	myism使用非聚簇索引，没有聚簇索引、非聚簇索引的b+树看上去一模一样。节点的结构完全一致，只是存储的内容不同。主键索引节点存储主键，辅佐索引存储辅助键。表数据存储在独立的地方。两颗数的叶子节点都使用一个地址指向表数据。辅助键检索无序访问主键的索引树。

​	设计大数据量的排序，全表扫描，count之类的操作。NyISAM占优势一些。因为索引占空间小，这些操作都是在内存中完成的。 



INNODB和MyISAM的区别

​	INNODB支持事务，MyISAM不支持事务	

​	INNODB支持外键，MyISAM不支持

​	MYSQL5.5以后，INNODB是默认引擎

​	INNODB支持行锁，表锁，MYISAM支持表锁

​	INNODB是聚簇索引，MYISAM是非聚簇索引

​	INNODB不保存行数

​	INNODB必须有唯一索引

​	MYISAM适合查询，InnoDB适合插删



Mysql索引有hash索引，B+数索引，InnoDB引擎默认B+树。

​	Hash索引，底层为hash表。单记录查询的时候性能最快。

​		哈希索引采用一定的hash算法，把建值换算为新的哈希值，检索时只需一次哈希算法即可定位到相应的位置，速度非常快。不支持联合索引。在大量重复键值下，因为哈希碰撞效率也很低。

​	B+数:

​		是一颗平衡多叉树，根节点到每个叶子节点高出不超过1，同层级有指针相互链接。在B+树的常规检索中，根节点到叶子节点的搜索效率基本相当。基于索引的顺序扫描可以利用双向指针快速左右移动。效率高。

​	索引设计的原则：查询更快，占用空间更小。

​		1、适合出现在where子句中的列，或者链接子句中指定的列（适合做条件）

​		2、基数较小的表不适合、

​		3、不要过度索引

​		4、更新频繁的字段不适合做索引。

​		5、尽量扩展索引，而不是新建索引



数据库锁

​	属性分类：共享锁，排他锁

​	粒度分类：行级锁（INNOODB），表级锁(INNODB,MYISAM)，页级锁(BDB引擎)，记录锁，间隙锁，临键锁（这些锁是正在的锁，上下分类是不同维度角度看待的锁）

​	状态分类：意向共享锁，意向排他锁

​	共享锁：读锁，一个事务对数据加上读锁，其他事务只能加读锁。不能够加写锁。直到所有读锁释放才能加写锁。共享锁是为了支持并发的读取数据。读取数据不支持修改，避免重复读。

​	排他锁：写锁，当一个事务加了读锁，其他请求不能再为数据加任何锁。知道锁释放。

​	表锁：锁住整个表，释放之后后面的事务才可以对表访问

​	行锁：值锁住某一行或多行。锁定行不能被访问。

​	记录锁：行锁的一种，只锁定一行。精准命中，命中的字段是唯一索引。

​	页锁：介于行锁和表锁之间，一次锁定相邻的一组记录，一组数据是多少由mysql设置决定。

​	间隙锁：根据相邻id之间的空隙锁住一个区间，左开右闭原则。

​	临建锁：记录所和间隙锁的组合，锁住一条记录方位内的所有间隙空间锁住。

​	意向排他锁：当一个事务试图对整个表加排他锁之前，需要获取这个表的意向排他锁（）写锁）

​	意向共享锁：当一个事务试图对这个表加共享锁之前，需要获取这个表的意向共享锁

​	

​	悲观锁：共享锁和排他锁.

​	乐观锁：CAS，版本号控制



第一范式：保证原则性（数据库都具有）

第二范式：有主键

第三范式：非主键字段不能相互依赖



MySQL执行计划

​	type:

​	system>const(索引一次命中，匹配一行数据)>rq-ref（唯一索引扫描，只有yi条记录匹配）>ref（非唯一索引扫描，匹配所有某个单独值得所有行）>range>index>all



ACID

​	原子性：要么全部程关，要么全部失败

​	一致性：从一个状态到另外一个状态总值不能发生改变。A:500,B:100 -》A:400 B:200 总值不发生变更

​	隔离性：一个事务得修改在提交前，其他事务不能看到

​	持久性：事务一旦提交，永久保存。



ru:读未提交，读到别人未提交的数据（脏读）

rc：读已提交，只能读取到已提交的数据（不可重复读）

rr：可重复读，一个事务中，第一次读到100，第二次读到50，已第一次为准。（幻读）

s：啥都解决了，锁表



慢查询的优化：

​	1、load不需要的列（抛弃掉不需要使用的列）

​	2、分析执行计划，看是否命中索引

​	3、是不是数据量过大，



ACID靠什么保证

​	A（原子性） undo log日志保证，他记录了需要回滚的日志信息

​	C（一致性）其他三大特性保证，数据一致性，业务代码保证

​	I（隔离性）MVCC保证

​	D（持久性）内存+redo log来保证



MVCC（多版本并发控制）

​	读取数据时通过一种类似快照的方式将数据保存下来，这样读锁和写锁就不冲突了，不同事务的session会看到自己特定版本的数据，

​	MVCC值正对rc（读已提交），rr（可重复读）两种级别下工作。ru总是读取最新数据，serializable对每一行数据都加锁。 

​	聚簇索引记录中有两个必要的隐藏列

​		trx_id：用来存储每次对某条聚簇索引数据进行修改时的事务id

​		roll_pointer：每次对聚簇索引记录进行修改，会把老版本写入undo日志。roll_pointer记录了上一个版本的位置。通过它来获取上一个版本的位置。

​		readview：事务开始就创建一个readview，readview将当前活动的事务id排序成一个数组。访问数据，获取数据中的事务id最大的记录，对比readview。如果readview在左边都可以访问（左边事务都已提交），在右边都不可访问，获取roll_pointer，屈上一个版本重新对比

​	读已提交的隔离级别每次查询数据都创建一个新的readview,可重复读隔离级别则在第一次读的适合创建一个readview，之后复用。



MySQL主从原理

​	MySql主从需要有三个线程，一个master线程，两个slave线程

​	主节点binlong，主从复制的基础是主库记录数据库的所有变更记录到binlog。

​	主节点log dump线程，当binlog有变动时，log dump线程读取其内容并发送给从节点

​	从节点接收binlog内容，写入relay log文件中

​	从节点的sql线程读取relay log文件内容对数据更新。最终保证主从数据库的一致性

​	主从节点使用binlog文件+position偏移量来定位主从同步的位置，从节点会保存其已接受到的偏移量，如果从节点宕机重启，则会自动从position的位置发起同步



​	由于mysql默认复制方式为异步，主库把日志发送给从库后不关系从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败。从库升级为主库会导致日志丢失。

​	全同步复制：等所有从节点执行完成后返回给客户端，性能过低

​	半同步复制：至少一个从库执行完就认为执行完了

​	

​	索引类型的性能

​		普通索引：允许索引值重复

​		唯一索引：数据唯一

​		主键索引：建立在聚簇索引之上，是一种特殊的唯一索引，一张表只有一个

​		联合索引：覆盖多个数据列

​		全文检索：倒排索引

​		索引可以极大提升查询速度：在查询过程中，使用优化隐藏器提升性能

​		会降低插入，删除，更新表的速度

​		索引需要占用物理空间。



CAP:

​	C 一致性： 更新操作返回给客户端后，所有节点同一时间数据一致

​	A 可用性：服务一直可用，正常相应。

​	P 分区容错性：节点直接发生网络故障，无法同步数据。

​	CP AP 必须牺牲一个

BASE:

​	基本可用：相应时间上允许损失

​						系统功能上允许损失，非核心功能可以停摆

​	软状态：数据同步允许一定延迟

​	最终一致性：系统中的所有数据副本，不要求试试，但最终需要一致。



负载均衡算法

​	轮询

​	随机

​	源地址哈希：使用ip地址通过哈希函数计算得到一个数值，然后对服务器列表大小取模。

​	加权轮询：一般进行百分比加权分配

​	加权随机：按照权重随机选择

​	最小连接数：谁轻松用谁



RPC：

​	本地调用远程函数，远程调用中可以跨语言

RMI：java实现的rpc机制，只能在jvm中使用



全局唯一id

​	uuid

​	数据库自增

​	leaft_segment:美团开源，一次存一定数据的id到数据库中，用完了在新增，也是自增的。对数据依赖较大，后加入双buff机制，第一个号段用了10%就开始缓存下一个号段

​	redis、mongodb、zk中间件生成、

​	雪花算法



分布式锁解决方案

​	 为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度 

​	数据库：通过与数据库的主键冲突控制，往该主键对应的数据上插入一个key，有key表示有锁，没key表示无锁。非阻塞，不可重入，单点，失效时间

​	zk

​	redis分布式锁：通过setNX(),setExpire()。setNX()有值返回失败，并设置过期时间，防止死锁，但还是会出现死锁。后期加入原子操作。两步合为一步，到期自动解锁。



接口幂等：

​	唯一id：根据内容生成唯一id

​	token验证：携带token，如果已存在则不允许在使用

​	建去重表

​	版本控制：

​	状态控制：



分布式事务： 分布式事务顾名思义就是要在分布式系统中实现事务，它其实是由多个本地事务组合而成。 

​	XA规范：四个角色![c2f1af08b6ac2c8bf7016a6542b5fd6](C:\Users\Administrator\Desktop\资料\c2f1af08b6ac2c8bf7016a6542b5fd6.png)

两阶段提交：

​	第一阶段：每个参与者执行本地事务，但不提交

​	第二阶段，当协调者认为参与者都ready后，通知参与者提交。

​	问题：单点故障问题：事务管理器出现故障，整个系统不可用

​				数据不一致：因为网路问题，有一部分参与者没有收到commot通知

​				响应时间长：参与者和协调者资源都会被锁住，直到提交或失败才能释放。

​				不确定：发送commit后，部分rm挂了

三阶段提交：解决两阶段单点故障问题，性能和一致性没有解决

​	第一阶段：检查环境是否正常

​	第二阶段：发送precommit消息，

​	第三阶段：发送docommit消息



TCC（补偿事务）Try confirm,cansle

​	try操作做业务检查及资源预留，confirm做业务确认，cansle做回滚。Tm发起所有分支事务try，任何一个出现问题，走cansle。try全部程关走confirm。出现失败会进行重试。

​	TCC代码侵入性较强，改造难度大。



本地消息表：

​	在本地将业务代码和消息存入数据库的代码加入事务，保证本地能执行成功，成功后发送消息通知其他程序执行，其他程序也成功修改数据库中数据的状态。开启定时扫描，执行失败的重发

最大努力通知

​	一个消息多次被调用失败了，然后丢弃掉并记录下来，走人工解决。

可靠消息最终一致性

​	保证消息可靠，最终达成一致，解决重复消费问题

​	

常用设计模式

​	单例：单例模式主要是为了避免多个实例的创建而造成资源浪费，且多个实例由于多次调用容易导致结果错误，使用单例可以保证整个应用有且只有一个实例。

​	工厂模式：别改代码，只需要添代码，以前所有的老代码，都是有价值的，需要尽力保留，factoryBean，传入不同的名字获取不同的bean

​		静态工厂： 类+静态方法 

​		简单工厂： 该模式通过向工厂传递类型来指定要创建的对象 （肉夹馍案例，创建肉夹馍基类，定义肉夹馍是什么，创建不同口味的肉夹馍，创建工厂类，通过传入不同的参数，返回不同口味的肉夹馍）（修改需要改代码）

​							优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象

​							缺点：不符合开闭原则，系统扩展困难

​		工厂方法： 定义一个创建对象的接口，但由子类决定要实例化的类是哪一个 （相比于简单工厂，更符合开闭原则，想要啥工厂就创建啥工厂，不改变其他工厂）

​							优点：工厂方法模式是为了克服简单工厂模式扩展困难的缺点

​							缺点：当同时需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦

​		抽象工厂： 提供一个接口，用于创建相关的或依赖对象的家族，而不需要明确指定具体类。 （肉夹馍的原材料就是依赖对象的家族，最后在产品上接收该工厂）

​							

​	装饰者模式：增加类的功能，但不改变原有代码（IO流就是装饰者模式，FileOutputStream就是OutputStream的装饰者）

​						优点：动态增加类的功能，但不改变原有代码

​						缺点：会产生多个类似的类

​	适配器模式：适配器让原本接口不兼容的类可以相互合作（有一部手机充电需要5v的充电头，现在有一个220v的充电头，创建一个适配器，传入220v输出5v,这样就可以给手机充电了）

​						优点：有更好的扩展性和复用性，解耦性，符合开闭原则

​						缺点：适配器过多会导致系统比较凌乱。

​						Spring中的应用：AfterReturningAdviceAdapter 传入Advice ,返回MethodInterceptor

​	动态代理：也就是说给定一个接口，动态代理就会实现接口下所有的方法

1、目标对象生成了接口 默认用JDK动态代理

2、如果目标对象使用了接口，可以强制使用cglib
3、如果目标对象没有实现接口，必须采用cglib库，Spring会自动在JDK动态代理和cglib之间转换

​	